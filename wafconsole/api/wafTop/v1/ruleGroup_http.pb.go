// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.0
// - protoc             v4.25.2
// source: api/wafTop/v1/ruleGroup.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationRuleGroupCreateRuleGroup = "/api.wafTop.v1.RuleGroup/CreateRuleGroup"
const OperationRuleGroupDeleteRuleGroup = "/api.wafTop.v1.RuleGroup/DeleteRuleGroup"
const OperationRuleGroupGetRuleGroup = "/api.wafTop.v1.RuleGroup/GetRuleGroup"
const OperationRuleGroupListRuleGroup = "/api.wafTop.v1.RuleGroup/ListRuleGroup"
const OperationRuleGroupUpdateRuleGroup = "/api.wafTop.v1.RuleGroup/UpdateRuleGroup"

type RuleGroupHTTPServer interface {
	CreateRuleGroup(context.Context, *CreateRuleGroupRequest) (*CreateRuleGroupReply, error)
	DeleteRuleGroup(context.Context, *DeleteRuleGroupRequest) (*DeleteRuleGroupReply, error)
	GetRuleGroup(context.Context, *GetRuleGroupRequest) (*GetRuleGroupReply, error)
	ListRuleGroup(context.Context, *ListRuleGroupRequest) (*ListRuleGroupReply, error)
	UpdateRuleGroup(context.Context, *UpdateRuleGroupRequest) (*UpdateRuleGroupReply, error)
}

func RegisterRuleGroupHTTPServer(s *http.Server, srv RuleGroupHTTPServer) {
	r := s.Route("/")
	r.POST("/app/wafTop/v1/ruleGroup", _RuleGroup_CreateRuleGroup0_HTTP_Handler(srv))
	r.PATCH("/app/wafTop/v1/ruleGroup", _RuleGroup_UpdateRuleGroup0_HTTP_Handler(srv))
	r.DELETE("/app/wafTop/v1/ruleGroup", _RuleGroup_DeleteRuleGroup0_HTTP_Handler(srv))
	r.GET("/app/wafTop/v1/ruleGroup/{id}", _RuleGroup_GetRuleGroup0_HTTP_Handler(srv))
	r.GET("/app/wafTop/v1/ruleGroups", _RuleGroup_ListRuleGroup0_HTTP_Handler(srv))
}

func _RuleGroup_CreateRuleGroup0_HTTP_Handler(srv RuleGroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateRuleGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRuleGroupCreateRuleGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateRuleGroup(ctx, req.(*CreateRuleGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateRuleGroupReply)
		return ctx.Result(200, reply)
	}
}

func _RuleGroup_UpdateRuleGroup0_HTTP_Handler(srv RuleGroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateRuleGroupRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRuleGroupUpdateRuleGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateRuleGroup(ctx, req.(*UpdateRuleGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateRuleGroupReply)
		return ctx.Result(200, reply)
	}
}

func _RuleGroup_DeleteRuleGroup0_HTTP_Handler(srv RuleGroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteRuleGroupRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRuleGroupDeleteRuleGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteRuleGroup(ctx, req.(*DeleteRuleGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteRuleGroupReply)
		return ctx.Result(200, reply)
	}
}

func _RuleGroup_GetRuleGroup0_HTTP_Handler(srv RuleGroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetRuleGroupRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRuleGroupGetRuleGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetRuleGroup(ctx, req.(*GetRuleGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetRuleGroupReply)
		return ctx.Result(200, reply)
	}
}

func _RuleGroup_ListRuleGroup0_HTTP_Handler(srv RuleGroupHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListRuleGroupRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationRuleGroupListRuleGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListRuleGroup(ctx, req.(*ListRuleGroupRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListRuleGroupReply)
		return ctx.Result(200, reply)
	}
}

type RuleGroupHTTPClient interface {
	CreateRuleGroup(ctx context.Context, req *CreateRuleGroupRequest, opts ...http.CallOption) (rsp *CreateRuleGroupReply, err error)
	DeleteRuleGroup(ctx context.Context, req *DeleteRuleGroupRequest, opts ...http.CallOption) (rsp *DeleteRuleGroupReply, err error)
	GetRuleGroup(ctx context.Context, req *GetRuleGroupRequest, opts ...http.CallOption) (rsp *GetRuleGroupReply, err error)
	ListRuleGroup(ctx context.Context, req *ListRuleGroupRequest, opts ...http.CallOption) (rsp *ListRuleGroupReply, err error)
	UpdateRuleGroup(ctx context.Context, req *UpdateRuleGroupRequest, opts ...http.CallOption) (rsp *UpdateRuleGroupReply, err error)
}

type RuleGroupHTTPClientImpl struct {
	cc *http.Client
}

func NewRuleGroupHTTPClient(client *http.Client) RuleGroupHTTPClient {
	return &RuleGroupHTTPClientImpl{client}
}

func (c *RuleGroupHTTPClientImpl) CreateRuleGroup(ctx context.Context, in *CreateRuleGroupRequest, opts ...http.CallOption) (*CreateRuleGroupReply, error) {
	var out CreateRuleGroupReply
	pattern := "/app/wafTop/v1/ruleGroup"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationRuleGroupCreateRuleGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *RuleGroupHTTPClientImpl) DeleteRuleGroup(ctx context.Context, in *DeleteRuleGroupRequest, opts ...http.CallOption) (*DeleteRuleGroupReply, error) {
	var out DeleteRuleGroupReply
	pattern := "/app/wafTop/v1/ruleGroup"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationRuleGroupDeleteRuleGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *RuleGroupHTTPClientImpl) GetRuleGroup(ctx context.Context, in *GetRuleGroupRequest, opts ...http.CallOption) (*GetRuleGroupReply, error) {
	var out GetRuleGroupReply
	pattern := "/app/wafTop/v1/ruleGroup/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationRuleGroupGetRuleGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *RuleGroupHTTPClientImpl) ListRuleGroup(ctx context.Context, in *ListRuleGroupRequest, opts ...http.CallOption) (*ListRuleGroupReply, error) {
	var out ListRuleGroupReply
	pattern := "/app/wafTop/v1/ruleGroups"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationRuleGroupListRuleGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *RuleGroupHTTPClientImpl) UpdateRuleGroup(ctx context.Context, in *UpdateRuleGroupRequest, opts ...http.CallOption) (*UpdateRuleGroupReply, error) {
	var out UpdateRuleGroupReply
	pattern := "/app/wafTop/v1/ruleGroup"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationRuleGroupUpdateRuleGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
